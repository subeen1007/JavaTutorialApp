※메소드, 패키지

<메소드>
●메소드란?
-객체의 동작(기능)
-호출해서 실행할 수 있는 중괄호 { } 블록
-메소드 호출하면 중괄호 { } 블록에 있는 모든 코드들이 일괄 실행

●메소드 선언
리턴타입  메소드이름  ([매개 변수선언, ... ]) {
       //실행할 코드를 작성하는 곳
                          ...
} 
→리턴타입: 메소드가 리턴하는 결과 타입 표시
→매개 변수선언: 메소드가 실행할 때 필요한 데이터를 받기 위한 변수
→{ ... }: 메소드 실행 블록

●메소드 리턴 타입
-메소드 실행된 후 리턴하는 값의 타입

-메소드는 리턴값이 있을 수도 있고 없을 수도 있음
	[메소드 선언]
	void powerOn() { ... }
	double divide(int x, int y) { ... }

	[메소드 호출]
	powerOn();
	double result = divide( 10, 20 );

●메소드 이름
-자바 식별자 규칙에 맞게 작성 

●메소드 매개변수 선언
-매개변수는 메소드를 실행할 때 필요한 데이터를 외부에서 받기 위해 사용
-매개변수도 필요 없을 수 있음

●리턴(return) 문
-메소드 실행을 중지하고 리턴값 지정하는 역할

-리턴값이 있는 메소드
    -반드시 리턴(return)문 사용해 리턴값 지정해야
    -return 문 뒤에 실행문 올 수 없음

-리턴값이 없는 메소드
    -메소드 실행을 강제 종료 시키는 역할


●메소드 호출
-메소드는 클래스 내∙외부의 호출에 의해 실행
    -클래스 내부: 메소드 이름으로 호출
    -클래스 외부: 객체 생성 후, 참조 변수를 이용해 호출


<메소드 오버로딩>
●메소드 오버로딩(Overloading)
-클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것
-하나의 메소드 이름으로 다양한 매개값 받기 위해 메소드 오버로딩
-오버로딩의 조건: 매개변수의 타입, 개수, 순서가 달라야함

class 클래스 {
    리턴타입  메소드이름  (타입변수, ...) { ... }
        ↑	          ↑	   ↑
       무관        동일         매개변수의 타입, 개수, 순서가 달라야 함
        ↓            ↓               ↓
    리턴타입  메소드이름  (타입변수, ...) { ... }
}


<인스턴스 멤버와 this>
●인스턴스 멤버란?
-객체(인스턴스) 마다 가지고 있는 필드와 메소드
    -이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부름

-인스턴스 멤버는 객체 소속된 멤버이기 때문에 객체가 없이 사용불가

●this
-객체(인스턴스) 자신의 참조(번지)를 가지고 있는 키워드
-객체 내부에서 인스턴스 멤버임을 명확히 하기 위해 this. 사용
-매개변수와 필드명이 동일할 때 인스턴스 필드임을 명확히 하기 위해 사용


<정적 멤버와 static>
●정적(static) 멤버란?
-클래스에 고정된 필드와 메소드 - 정적 필드, 정적 메소드
-정적 멤버는 클래스에 소속된 멤버
    -객체 내부에 존재하지 않고, 메소드 영역에 존재
    -정적 멤버는 객체를 생성하지 않고 클래스로 바로 접근해 사용

●정적 멤버 선언
-필드 또는 메소드 선언할 때 static 키워드 붙임
public class 클래스 {
    //정적 필드
    static 타입 필드 [= 초기값];

    //정적 메소드
    static 리턴타입 메소드 ( 매개변수 선언, ... ) { ... }
}

●정적(static) 멤버 사용
-클래스 이름과 함께 도트(.) 연산자로 접근
	클래스.필드;
	클래스.메소드(매개값, ...);
-EX)
public class Calculator {
    static double pi = 3.14159;
    static int plus(int x, int y) { ... }
    static int minus(int x, int y) { ... }
}
[바람직한 사용]
double result1 = 10 * 10 * Calculator.pi;
int result2 = Calculator.plus(10. 5);
int result3 = Calculator.minus(10. 5);

[바람직하지 못한 사용]
Calculator myCalcu = new Calculator();
double result1 = 10 * 10 * myCalcu.pi;
int result2 = Calculator.plus(10. 5);
int result3 = Calculator.minus(10. 5);

●인스턴스 멤버 선언 vs 정적 멤버 선언의 기준
-필드
    -객체 마다 가지고 있어야 할 데이터 →인스턴스 필드
    -공용적인 데이터 →정적 필드
	public class Calcuator{
	    String color;			//계산기 별로 색깔이 다를 수 있다.
	    static double pi = 3.14159;	//계산기에서 사용하는 파이값은 동일하다.
	}

-메소드
    -인스턴스 필드로 작업해야 할 메소드 → 인스턴스 메소드
    -인스턴스 필드로 작업하지 않는 메소드 → 정적(static) 메소드

●정적 초기화 블록
-클래스가 메소드 영역으로 로딩될 때 자동으로 실행하는 블록
	static{
	    ...
	}

-정적 필드의 복잡한 초기화 작업과 정적 메소드 호출 가능
-클래스 내부에 여러 개가 선언되면 선언된 순서대로 실행

●정적 메소드와 정적 블록 작성시 주의할 점
-객체가 없어도 실행 가능
-블록 내부에 인스턴스 필드나 인스턴스 메소드 사용 불가
-객체 자신의 참조인 this 사용 불가
    -EX) main()


<final 필드와 상수(static final)>
●final 필드
-최종적인 값을 갖고 있는 필드 = 값을 변경할 수 없는 필드
-final 필드의 딱 한번의 초기값 지정 방법
    -필드 선언 시
    -생성자

●상수(static final)
-상수 = 정적 final 필드
    -final 필드: 
        -객체마다 가지는 불변의 인스턴스 필드

    -상수(static final): 
        -객체마다 가지고 있지 않음
        -메소드 영역에 클래스 별 로 관리되는 불변의 정적 필드 
        -공용 데이터로서 사용

-상수 이름은 전부 대문자로 작성

-다른 단어가 결합되면 _ 로 연결


<패키지(package)>
●패키지란?
-클래스를 기능별로 묶어서 그룹 이름을 붙여 놓은 것
    -파일들을 관리하기 위해 사용하는 폴더(디렉토리)와 비슷한 개념
    -패키지의 물리적인 형태는 파일 시스템의 폴더

-클래스 이름의 일부
    -클래스를 유일하게 만들어주는 식별자
    -전체 클래스 이름 = 상위패키지.하위패키지.클래스
    -클래스명이 같아도 패키지명이 다르면 다른 클래스로 취급

	상위패키지
	    ⤷하위패키지
		⤷클래스. class, ...
	    ⤷하위패키지
		⤷클래스. class, ...

-클래스 선언할 때 패키지 결정
    -클래스 선언할 때 포함될 패키지 선언
    -클래스 파일은(~.class) 선언된 패키지와 동일한 폴더 안에서만 동작
    -클래스 파일은(~.class) 다른 폴더 안에 넣으면 동작하지 않음

●import 문
-패키지 내에 같이 포함된 클래스간 클래스 이름으로 사용 가능
-패키지가 다른 클래스를 사용해야 할 경우
    1)패키지 명 포함된 전체 클래스 이름으로 사용
	package com.mycompany;
	
	public class Car {
	    com.hankook.Tire tire = new com.hankook.Tire();
	}

    2)Import 문으로 패키지를 지정하고 사용
	package com.mycompany;

	import com.hankook.Tire;
	[ 또는 import com.hankook.*; ]

	public class Car {
	   Tire tire = new Tire();
	}


<접근 제한자>
●접근 제한자(Access Modifier)
-클래스 및 클래스의 구성 멤버에 대한 접근을 제한하는 역할
    -다른 패키지에서 클래스를 사용하지 못하도록 (클래스 제한)
    -클래스로부터 객체를 생성하지 못하도록 (생성자 제한)
    -특정 필드와 메소드를 숨김 처리 (필드와 메소드 제한)

-접근 제한자의 종류
private  ⊂  default  ⊂  protected  ⊂  public	
	
접근제한		적용대상				접근할 수 없는 클래스
public		클래스, 필드, 생성자, 메소드		없음
protected	필드, 생성자, 메소드		자식 클래스가 아닌 다른 패키지에 소속된 클래스
default		클래스, 필드, 생성자, 메소드		다른 패키지에 소속된 클래스
private		필드, 생성자, 메소드		모든 외부 클래스

●클래스의 접근 제한
-default 
    -클래스 선언할 때 public 생략한 경우 
    -다른 패키지에서는 사용 불가

-public
    -다른 개발자가 사용할 수 있도록 라이브러리 클래스로 만들 때 유용

●생성자 접근 제한 
-생성자가 가지는 접근 제한에 따라 호출 여부 결정

●필드와 메소드의 접근 제한
-클래스 내부, 패키지 내, 패키지 상호간에 사용할 지 고려해 선언


<Getter와 Setter>
●클래스 선언할 때 필드는 일반적으로 private 접근 제한
-읽기 전용 필드가 있을 수 있음 (Getter의 필요성)
-외부에서 엉뚱한 값으로 변경할 수 없도록 (Setter의 필요성)

●Getter
-private 필드의 값을 리턴 하는 역할 - 필요할 경우 필드 값 가공
-getFieldName() 또는 isFieldName() 메소드
    -필드 타입이 boolean 일 경우 isFieldName()

●Setter
-외부에서 주어진 값을 필드 값으로 수정
    -필요할 경우 외부의 값을 유효성 검사
-setFieldName(타입 변수) 메소드
    -매개 변수 타입은 필드의 타입과 동일

