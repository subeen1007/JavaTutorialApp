※클래스, 객체

<객체지향 프로그래밍이란?>
●객체 지향 프로그래밍이란
-우리가 살고 있는 실제 세계가 객체들로 구성되어 있는것과 비슷하게 소프트웨어도 객체로 구성하는 방법
-부품 객체를 먼저 만들고 이것들을 하나씩 조립해 완성된 프로그램을 만드는 기법

●객체(Object)
-객체는 상태와 동작을 가지고 있다.
-객체의 상태(state)는 객체의 특징값(속성)이다. 
-객체의 동작(behavior) 또는 행동은 객체가 취할 수 있는 동작
-EX)TV객체
    상태: 채널번호, 볼륨, 전원상태
    동작: 켜기, 끄기, 채널변경하기, 볼륨변경하기


●필드와 메소드
-필드 : 객체 안의 변수 EX)int volume;
-메소드 EX)turnOn()
-객체=필드+메소드 인 소프트웨어 묶음


●객체간의 관계
객체 지향 프로그램에서는 객체는 다른 객체와 관계를 맺음
관계의 종류
집합 관계: 완성품과 부품의 관계
사용 관계: 객체가 다른 객체를 사용하는 관계
상속 관계: 종류 객체와  구체적인 사물 객체 관계

         (사용관계)       (상속관계)
사람객체  →  자동차객체  →  기계객체
                                  ↘  엔진객체, 타이어객체, 핸들객체
		     (집합관계)

<객체 지향 프로그래밍의 특징>
-캡슐화, 상속, 다형성

●캡슐화
1)객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것
2)외부 객체는 객체 내부 구조를 알지 못하며 객체가 노출해 제공하는 필드와 메소드만 이용 가능
3)필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 
4)자바 언어는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지 결정하기 위해 접근 제한자(Access Modifier) 사용

외부객체 → 노출 메소드
        (호출 O)
            → 노출 데이터
    (읽기/쓰기 O)
            → 숨긴데이터  
    (읽기/쓰기 X)
            → 숨긴 메소드
       (호출 X)

●상속
1)상위(부모) 객체의 필드와 메소드를 하위(자식) 객체에게 물려주는 행위
2)하위 객체는 상위 객체를 확장해서 추가적인 필드와 메소드를 가질 수 있음
3)상속 대상: 필드와 메소드
4)상속의 효과
    -기존 코드 재활용 → 새로운 기능 추가 또는 변경이 가능
    -반복된 코드의 중복을 줄임
    -유지 보수의 편리성 제공
    -객체의 다형성 구현

●다형성 (Polymorphism)
1)같은 타입이지만 실행 결과가 다양한 객체를 대입할 수 있는 성질
    -부모 타입에는 모든 자식 객체가 대입
    -인터페이스 타입에는 모든 구현 객체가 대입
2)효과
    -객체를 부품화시키는 것 가능
    -유지보수 용이
3)다형성은 객체를 부품화 시킨다. 
EX)자동차는 타이어 타입으로 한국 타이어와 금호 타이어를 사용하지만 각 타이어의 성능은 다르게 나온다.


<클래스 기초>
●객체(Object)와 클래스(Class)
-클래스(class): 객체를 만드는 설계도

-현실세계:  설계도 → 객체
-자바:        클래스 → 객체
-클래스에는 객체를 생성하기 위한 필드와 메소드가 정의
-클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다.
-하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있음

●클래스의 구조
-형식:
class 클래스이름{
	자료형 필드1;   // 필드 정의, 객체의 속성을 나타낸다.
	자료형 필드2;
	...
	반환형 메소드1(){ ... }   // 메소드 정의, 객체의 동작을 나타낸다.
	반환형 메소드2(){ ... }
}

●new 연산자
-객체 생성 역할
    new 클래스();
    1)클래스()는 생성자를 호출하는 코드
    2)생성된 객체는 힙 메모리 영역에 생성

-new 연산자는 객체를 생성 후, 객체 생성 번지 리턴

●객체 생성하기

        (참조변수 선언)
                ↑
- Television tv = new Television();
       ↓                     ↓
   (클래스)            ( 객체 생성 ) 

●객체의 필드와 메소드에 접근하기
-도트(.) 연산자 사용!
-형식:
tv.channel = 7;  //tv가 참조하는 객체로부터, channel이라는 필드에 접근

●여러개의 객체 생성하기
-형식:
Television mytv = new Television();  // 첫번째 객체의 이름은 myTv이다. 
Television yourtv = new Television();  //두번째 객체의 이름은 yourTv이다.
→같은 Television클래스로부터 여러개의 객체를 생성

●클래스의 구성 멤버
-필드(Field): 객체의 데이터가 저장되는 곳
-생성자(Constructor): 객체 생성시 초기화 역할 담당(생성자는 클래스명과 이름이 같으며, 반환형(void, int 등)이 없다)
-메소드(Method): 객체의 동작에 해당하는 실행블록

public class ClassName{
	int fieldName; //필드
	ClassName(){ ... } //생성자
	void methodName() { ... } //메소드
}


<생성자>
●생성자(Constructor)
-생성자
    -new 연산자에 의해 호출되어 객체의 초기화 담당
        -EX)new 클래스();
        -필드의 값 설정
        -메소드 호출해  객체를 사용할 수 있도록 준비하는 역할 수행
-기본 생성자(Default Constructor)
    -모든 클래스는 생성자가 반드시 존재하며 하나 이상 가질 수 있음
    -생성자 선언을 생략하면 컴파일러는 자동적으로 기본 생성자 추가

●생성자 선언
-디폴트 생성자 대신 개발자가 직접 선언
	클래스(매개 변수 선언,...) {
		//객체의 초기화 코드      →생성자 블록
	}

-개발자 선언한 생성자 존재 시 컴파일러는 기본 생성자 추가하지 않음
	-new 연산자로 객체 생성시 개발자가 선언한 생성자 반드시 사용
	public class Car{
		Car(String model, String color, int maxSpeed) { ... }  //생성자
	} 

	Car myCar = new Car("그랜저", "검정", 300);

●필드 초기화
-초기값 없이 선언된 필드는 객체가 생성될 때 기본값으로 자동 설정

-다른 값으로 필드 초기화하는 방법
	-필드 선언할 때 초기값 설정
	-생성자의 매개값으로 초기값 설정
		Korean k1 = new Korean ("박자바", "011225-1234567");
		Korean k2 = new Korean ("김자바", "930525-0654321");
	-매개 변수와 필드명 같은 경우 this 사용

●생성자 다양화해야 하는 이유
-객체 생성할 때 외부 값으로 객체를 초기화할 필요
-외부 값이 어떤 타입으로 몇 개가 제공될 지 모름 - 생성자도 다양화


<생성자 오버로딩>
●생성자 오버로딩(Overloading)  
-매개변수의 타입, 개수, 순서가 다른 생성자 여러 개 선언

●this로 현재 객체 나타내기
-메소드나 생성자에서 this는 현재 객체를 나타낸다.
-this를 이용하여 현재 객체의 어떤 멤버도 참조할 수 있다.
-this()와 같이 this뒤에 ()를 붙이면 생성자 호출이 된다.
-자바에서 매개변수와 필드가 이름이 같으면 매개변수가 필드를 가리게 된다. 이 경우에 this를 사용하면 필드를 참조할 수 있다.

●다른 생성자 호출( this() )
-생성자 오버로딩되면 생성자 간의 중복된 코드 발생
-초기화 내용이 비슷한 생성자들에서 이러한 현상을 많이 볼 수 있음
	-초기화 내용을 한 생성자에 몰아 작성
	-다른 생성자는 초기화 내용을 작성한 생성자를 this( … )로 호출

-하나의 클래스 안에서 생성자는 여러개 작성될 수 있다. 생성자의 매개변수만 다르면 된다.
-자바에서는 매개변수만 다르면 동일한 이름의 메소드를 여러 개 생성할 수 있다. 이를 메소드 오버로딩이라 부른다.

